BeginPackage["Macaulay2`"];
(* global definitions *)

WriteMacaulay2Script::usage = "Writes a script for the external program Macaulay2, which will calculate the resultant";
RunMacaulay2Script::usage = "Runs a given Macaulay2 script";
ReadResultantFromFile::usage = "Reads the output of a Macaulay2 script and imports it into mathematica";
TransformPolynomialsToIntegerRing::usage = "Transforms given polynomials to polynomials over an integer ring";
MakeHomogeneousCoefficients::usage = "Transforms given polynomials to polynomials which are homogeneous in their coefficients";
MakeRationalCoefficients::usage = "Transforms given polynomials to polynomials with rational numeric coefficients";
GetResultant::usage = "Calculates the resultant of a given set of polynomials using the package Macaulay2";


Begin["`Private`"];
(* private defintions *)

PackageDirectory = DirectoryName[$InputFileName];
Get[FileNameJoin[{PackageDirectory, "config.m"}]];


(* ---------------------------------------------------------------------------------------------------- *)
(* function: WriteMacaulay2Script[...]                                                                  *)
(* description: Writes a script for the external program Macaulay2, which will calculate the resultant  *)
(*              of a given set of variables, parameters and polynomials                                 *)
(* arguments: scriptname - filename of the script                                                       *)
(*            outputname - filename for the output generated by the script                              *)
(*            polynomials - list of polynomials                                                         *)
(*            variables - list of polynomial variables                                                  *)
(*            parameters - list of polynomial parameters                                                *)
(* options: IntegerRing - False/True for using an integer ring instead of rationals                     *)
(*          Algorithm - "Poisson"/"Macaulay"/"Poisson2"/"Macaulay2"                                     *)
(* return value: <| "ErrorCode" -> 0 on success, -1 on error |>                                         *)
(* ---------------------------------------------------------------------------------------------------- *)
Options[WriteMacaulay2Script] = {
	IntegerRing -> False,
	Algorithm -> "Poisson"
};
WriteMacaulay2Script[scriptname_String, outputname_String, polynomials_List, variables_List, parameters_List, opts:OptionsPattern[]] := Module[
	(* local variables *)
	{listvars, listpars, listpols, Macaulay2Field, Macaulay2ScriptLines, Macaulay2File}
	,
	(* consistency checks *)
	If[Length[variables] =!= Length[polynomials],
		WriteLine["stderr", "error in WriteMacaulay2Script: number of polynomials does not match number of variables"];
		Return[<| "ErrorCode" -> -1 |>];
	];

	If[BooleanQ[OptionValue[IntegerRing]] == False,
		WriteLine["stderr", "error in WriteMacaulay2Script: option IntegerRing is not boolean"];
		Return[<| "ErrorCode" -> -1 |>];
	];

	If[MemberQ[{"Poisson", "Macaulay", "Poisson2", "Macaulay2"}, OptionValue[Algorithm]] == False,
		WriteLine["stderr", "error in WriteMacaulay2Script: unknown algorithm"];
		Return[<| "ErrorCode" -> -1 |>];
	];

	(* code *)
	listvars = "[";
	Do[
		listvars = listvars <> ToString[variables[[ii]], InputForm] <> ", ";
		,
		{ii, 1, Length[variables] - 1}
	];
	listvars = listvars <> ToString[variables[[-1]], InputForm] <> "]";

	listpars = "[";
	Do[
		listpars = listpars <> ToString[parameters[[ii]], InputForm] <> ", ";
		,
		{ii, 1, Length[parameters] - 1}
	];
	If[Length[parameters] != 0,
		listpars = listpars <> ToString[parameters[[-1]], InputForm] <> "]";
		,
		listpars = listpars <> "]";
	];

	listpols = "{";
	Do[
		listpols = listpols <> ToString[polynomials[[ii]], InputForm] <> ", ";
		,
		{ii, 1, Length[polynomials] - 1}
	];
	listpols = listpols <> ToString[polynomials[[-1]], InputForm] <> "}";

	Macaulay2Field = "QQ";
	If[OptionValue[IntegerRing],
		Macaulay2Field = "ZZ"
	];

	Macaulay2ScriptLines = {
		"loadPackage \"Resultants\"",
		Macaulay2Field <> listpars <> listvars,
		"inputpolynomials = " <> listpols,
		"charpolynomial = resultant(inputpolynomials, Algorithm=>\""<>OptionValue[Algorithm]<>"\")",
		"\"" <> outputname <> "\"" <> " << toString(charpolynomial) << endl << close"
	};

	If[FileExistsQ[scriptname], DeleteFile[scriptname]];
	If[FileExistsQ[outputname], DeleteFile[outputname]];
	Macaulay2File = CreateFile[scriptname];
	Do[
		WriteLine[Macaulay2File, Macaulay2ScriptLines[[ii]]];
		,
		{ii, 1, Length[Macaulay2ScriptLines]}
	];
	Close[Macaulay2File];

	Return[<| "ErrorCode" -> 0 |>];
];


(* ---------------------------------------------------------------------------------------------------- *)
(* function: RunMacaulay2Script[...]                                                                    *)
(* description: Runs a given Macaulay2 script                                                           *)
(* arguments: scriptname - filename of the script                                                       *)
(* options: None                                                                                        *)
(* return value: <| "ErrorCode" -> 0 on success, -1 on error |>                                         *)
(* ---------------------------------------------------------------------------------------------------- *)
RunMacaulay2Script[scriptname_String] := Module[
	(* local variables *)
	{retval, starttime}
	,
	(* consistency checks *)
	If[FileExistsQ[scriptname] == False,
		WriteLine["stderr", "error in RunMacaulay2Script: script does not exist"];
		Return[<| "ErrorCode" -> -1 |>];
	];

	If[FileExistsQ[Macaulay2Binary] == False && Run["which "<>Macaulay2Binary<>" >> /dev/null"] != 0,
		WriteLine["stderr", "error in RunMacaulay2Script: Macaulay2 binary does not exist"];
		Return[<| "ErrorCode" -> -1 |>];
	];

	(* code *)
	starttime = UnixTime[];
	retval = Run[Macaulay2Binary, "--script", scriptname];
	If[retval =!= 0,
		WriteLine["stderr", "error in RunMacaulay2Script: script ended with bad exit code"];
		Return[<| "ErrorCode" -> -1 |>];
	];
	WriteLine["stderr", "runtime of " <> scriptname <> ": " <> ToString[(UnixTime[] - starttime) / 60.0, OutputForm] <> " minutes"];

	Return[<| "ErrorCode" -> 0 |>];
];


(* ---------------------------------------------------------------------------------------------------- *)
(* function: ReadResultantFromFile[...]                                                                 *)
(* description: Reads the output of a Macaulay2 script and imports it into mathematica                  *)
(* arguments: filename - filename of the output                                                         *)
(* options: None                                                                                        *)
(* return value: <| "ErrorCode" -> 0 on success, -1 on error, "Resultant" |>                            *)
(* ---------------------------------------------------------------------------------------------------- *)
ReadResultantFromFile[filename_String] := Module[
	(* local variables *)
	{charpolynomial, homogenpardummy}
	,
	(* consistency checks *)
	If[FileExistsQ[filename] == False,
		WriteLine["stderr", "error in ReadResultantFromFile: output file does not exist"];
		Return[<| "ErrorCode" -> -1, "Resultant" -> Null |>];
	];

	(* code *)
	homogenpardummy = ToExpression["homogenpar"];
	charpolynomial = ToExpression[Import[filename]];
	charpolynomial = Expand[charpolynomial /. homogenpardummy -> 1];
	Return[<| "ErrorCode" -> 0, "Resultant" -> charpolynomial |>];
];


(* ---------------------------------------------------------------------------------------------------- *)
(* function: TransformPolynomialsToIntegerRing[...]                                                     *)
(* description: Transforms given polynomials to polynomials over an integer ring                        *)
(* arguments: polynomials - list of polynomials                                                         *)
(*            variables - list of polynomial variables                                                  *)
(*            ignoreparameters = list of analytic parameters that should be ignored (will be set to 1)  *)
(* options: None                                                                                        *)
(* return value: <| "ErrorCode" -> 0 on success, -1 on error, "Polynomials" |>                          *)
(* ---------------------------------------------------------------------------------------------------- *)
TransformPolynomialsToIntegerRing[polynomials_List, variables_List, ignoreparameters_List:{}] := Module[
	(* local variables *)
	{errorcode, subrules, newpolynomials = polynomials, coefflist, multiplicationfactor}
	,
	(* consistency checks *)
	If[Length[variables] == 0,
		WriteLine["stderr", "error in TransformPolynomialsToIntegerRing: number of variables is zero"];
		Return[<| "ErrorCode" -> -1, "Polynomials" -> Null |>];
	];

	(* code *)
	errorcode = 0;
	subrules = Table[ignoreparameters[[ii]] -> 1, {ii, 1, Length[ignoreparameters]}];

	Do[
		coefflist = CoefficientList[polynomials[[ii]] /. subrules, variables];
		coefflist = Flatten[coefflist];
		coefflist = Select[coefflist, # =!= 0 &];
		coefflist = Denominator[coefflist];
		multiplicationfactor = LCM[Apply[Sequence, coefflist], 1];

		If[NumberQ[multiplicationfactor] == False,
			errorcode = -1;
		];

		newpolynomials[[ii]] = Expand[polynomials[[ii]] * multiplicationfactor];
		,
		{ii, 1, Length[polynomials]}
	];

	If[errorcode != 0,
		WriteLine["stderr", "error in TransformPolynomialsToIntegerRing: cannot find LCM - probably one analytic denominator left"];
		Return[<| "ErrorCode" -> -1, "Polynomials" -> Null |>];
	];

	Return[<| "ErrorCode" -> 0, "Polynomials" -> newpolynomials |>];
];


(* ---------------------------------------------------------------------------------------------------- *)
(* function: MakeHomogeneousCoefficients[...]                                                           *)
(* description: Transforms given polynomials to polynomials which are homogeneous in their coefficients *)
(* arguments: polynomials - list of polynomials                                                         *)
(*            paramters = list of polynomial parameters                                                 *)
(* options: None                                                                                        *)
(* return value: <| "ErrorCode" -> 0 on success, -1 on error, "Polynomials", "Parameters" |>            *)
(* ---------------------------------------------------------------------------------------------------- *)
MakeHomogeneousCoefficients[polynomials_List, parameters_List] := Module[
	(* local variables *)
	{newpolynomials = polynomials, newparameters = parameters, numpars, homogenpardummy, coefflist, coeffdim, coeffmaxdim, sinexplist, allexplist}
	,
	(* consistency checks *)
	If[Length[parameters] == 0,
		WriteLine["stderr", "error in MakeHomogeneousCoefficients: number of parameters is zero"];
		Return[<| "ErrorCode" -> -1, "Polynomials" -> Null, "Parameters" -> Null |>];
	];

	(* code *)
	numpars = Length[parameters];
	homogenpardummy = ToExpression["homogenpar"];

	Do[
		coefflist = CoefficientList[polynomials[[ii]], parameters];
		coeffdim = Dimensions[coefflist];
		coeffmaxdim = Max[coeffdim] - 1;
		sinexplist = Table[Range[1, coeffdim[[jj]]], {jj, 1, numpars}];
		allexplist = Flatten[Outer[List, Apply[Sequence, sinexplist]], numpars-1];
		newpolynomials[[ii]] = Expand[Sum[
			coefflist[[ Apply[ Sequence, allexplist[[jj]] ] ]] * Product[
				parameters[[kk]]^(allexplist[[jj,kk]] - 1)
				,
				{kk, 1, numpars}
			] * homogenpardummy^(coeffmaxdim - (Total[allexplist[[jj]]] - numpars))
			,
			{jj, 1, Length[allexplist]}
		]];
		,
		{ii, 1, Length[polynomials]}
	];
	
	newparameters = Join[parameters, {homogenpardummy}];

	Return[<| "ErrorCode" -> 0, "Polynomials" -> newpolynomials, "Parameters" -> newparameters |>];
];


(* ---------------------------------------------------------------------------------------------------- *)
(* function: MakeRationalCoefficients[...]                                                              *)
(* description: Transforms given polynomials to polynomials with rational numeric coefficients          *)
(* arguments: polynomials - list of polynomials                                                         *)
(*            dx = maximal error of rationals                                                           *)
(* options: None                                                                                        *)
(* return value: <| "ErrorCode" -> 0 on success, -1 on error, "Polynomials" |>                          *)
(* ---------------------------------------------------------------------------------------------------- *)
MakeRationalCoefficients[polynomials_List, dx_] := Module[
	(* local variables *)
	{newpolynomials = polynomials}
	,
	(* consitency checks *)
	If[NumberQ[dx] == False,
		WriteLine["stderr", "error in MakeRationalCoefficients: rational accuracy is no number"];
		Return[<| "ErrorCode" -> -1, "Polynomials" -> Null |>];
	];

	If[dx < 0,
		WriteLine["stderr", "error in MakeRationalCoefficients: rational accuracy is negative"];
		Return[<| "ErrorCode" -> -1, "Polynomials" -> Null |>];
	];

	(* code *)
	Do[
		newpolynomials[[ii]] = Rationalize[polynomials[[ii]], dx];
		,
		{ii, 1, Length[polynomials]}
	];

	Return[<| "ErrorCode" -> 0, "Polynomials" -> newpolynomials |>];
];


(* ---------------------------------------------------------------------------------------------------- *)
(* function: GetResultant[...]                                                                          *)
(* description: Calculates the resultant of a given set of polynomials using the package Macaulay2      *) 
(* arguments: polynomials - list of polynomials                                                         *)
(*            variables - list of polynomial variables                                                  *)
(*            parameters - list of polynomial parameters                                                *)
(* options: ScriptName - Macaulay2 script name, which will be generated                                 *)
(*          OutputName - Macaulay2 output file name                                                     *)
(*          RationalAccuracy - accuracy for float values                                                *)
(*          IntegerRing - False/True for using an integer ring instead of rationals                     *)
(*          Algorithm - "Poisson"/"Macaulay"/"Poisson2"/"Macaulay2"                                     *)
(* return value: <| "ErrorCode" -> 0 on success, -1 on error, "Resultant" |>                            *)
(* ---------------------------------------------------------------------------------------------------- *)
Options[GetResultant] = {
	ScriptName -> "script.m2",
	OutputName -> "script.out",
	RationalAccuracy -> 0.001,
	IntegerRing -> False,
	Algorithm -> "Poisson"
};
GetResultant[polynomials_List, variables_List, parameters_List, opts:OptionsPattern[]] := Module[
	(* local variables *)
	{newpolynomials = polynomials, newparameters = parameters, retval}
	,
	(* consistency checks *)
	If[StringQ[OptionValue[ScriptName]] == False,
		WriteLine["stderr", "error in GetResultant: option ScriptName is no string"];
		Return[<| "ErrorCode" -> -1, "Resultant" -> Null |>];
	];

	If[StringQ[OptionValue[OutputName]] == False,
		WriteLine["stderr", "error in GetResultant: option OutputName is no string"];
		Return[<| "ErrorCode" -> -1, "Resultant" -> Null |>];
	];

	If[NumberQ[OptionValue[RationalAccuracy]] == False,
		WriteLine["stderr", "error in GetResultant: option RationalAccuracy is no number"];
		Return[<| "ErrorCode" -> -1, "Resultant" -> Null |>];
	];

	If[BooleanQ[OptionValue[IntegerRing]] == False,
		WriteLine["stderr", "error in GetResultant: option IntegerRing is not boolean"];
		Return[<| "ErrorCode" -> -1, "Resultant" -> Null |>];
	];

	If[MemberQ[{"Poisson", "Macaulay", "Poisson2", "Macaulay2"}, OptionValue[Algorithm]] == False,
		WriteLine["stderr", "error in GetResultant: unknown algorithm"];
		Return[<| "ErrorCode" -> -1, "Resultant" -> Null |>];
	];

	(* code *)

	(* make rational coefficients *)
	retval = MakeRationalCoefficients[polynomials, OptionValue[RationalAccuracy]];
	If[retval[["ErrorCode"]] =!= 0,
		Return[<| "ErrorCode" -> -1, "Resultant" -> Null |>];
	];

	newpolynomials = retval[["Polynomials"]];

	(* make coefficients homogeneous if needed *)
	If[StringContainsQ[OptionValue[Algorithm], "2"],
		retval = MakeHomogeneousCoefficients[newpolynomials, newparameters];
		If[retval[["ErrorCode"]] =!= 0,
			Return[<| "ErrorCode" -> -1, "Resultant" -> Null |>];
		];

		newpolynomials = retval[["Polynomials"]];
		newparameters = retval[["Parameters"]];
	];

	(* transform to integer ring if needed *)
	If[OptionValue[IntegerRing],
		retval = TransformPolynomialsToIntegerRing[newpolynomials, variables];
		If[retval[["ErrorCode"]] =!= 0,
			Return[<| "ErrorCode" -> -1, "Resultant" -> Null |>];
		];

		newpolynomials = retval[["Polynomials"]];
	];

	(* generate script *)
	retval = WriteMacaulay2Script[OptionValue[ScriptName], OptionValue[OutputName], newpolynomials, variables, newparameters, FilterRules[{opts}, Options[WriteMacaulay2Script]]];
	If[retval[["ErrorCode"]] =!= 0,
		Return[<| "ErrorCode" -> -1, "Resultant" -> Null |>];
	];

	(* run script *)
	retval = RunMacaulay2Script[OptionValue[ScriptName]];
	If[retval[["ErrorCode"]] =!= 0,
		Return[<| "ErrorCode" -> -1, "Resultant" -> Null |>];
	];

	(* read output *)
	retval = ReadResultantFromFile[OptionValue[OutputName]];
	If[retval[["ErrorCode"]] =!= 0,
		Return[<| "ErrorCode" -> -1, "Resultant" -> Null |>];
	];

	(* return resultant *);
	Return[<| "ErrorCode" -> 0, "Resultant" -> retval[["Resultant"]] |>];
];


End[];
EndPackage[];

